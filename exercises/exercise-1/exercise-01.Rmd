---
title: "CeDoSIA SS2020 - Exercise Sheet 1: Introduction to R"
author: "Vangelis Theodorakis, Xueqi Cao, Daniela Andrade Salazar, Julien Gagneur"
date: "`r format(Sys.time(), '%d %B, %Y')`"
vignette: >
  %\VignetteIndexEntry{CeDoSIA SS2020 - Exercise Sheet 1: Introduction to R}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
output: 
  BiocStyle::pdf_document
---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(fig.width=12, fig.height=12, error=TRUE, warning=FALSE,
        message=FALSE, 
        echo=FALSE, results="hide"
        # echo=TRUE, results="show"
)
```

# Vectors 

First, create three named numeric vectors of size 10, 11 and 12 respectively in the following manner: 

- One vector with the "colon" approach: *from:to*
- One vector with the `seq()` function: *seq(from, to)*
- And one vector with the `seq()` function and the `by` argument: *seq(from, to, by)*

For easier naming you can use the vector `letters` or `LETTERS` which contain the latin alphabet in small and capital, respectively. In order to select specific letters just use e.g. `letters[1:4]` to get the first four letters. 
Check their types. What is the outcome? Where do you think the difference comes from?

Then combine all three vectors in a list. Check the attributes of the vectors and the list. What is the difference and why?


**Hint:** If list elements have no names, we can access them with the double brackets and an index, e.g. `my_list[[1]]`

```{r}
# Answer :

# A. Create vectors
vector.1 <- 1:10
names(vector.1) <- letters[vector.1]

vector.2 <- seq(1, 11)
names(vector.2) <- letters[vector.2]

vector.3 <- seq(1, 12, by = 1)
names(vector.3) <- letters[vector.3]

typeof(vector.1)
typeof(vector.2)
typeof(vector.3)

# B. Combine in a list
awesome.list <- list(vector.1, vector.2, vector.3)
attributes(vector.1)
attributes(vector.2)
attributes(vector.3)
attributes(awesome.list)
attributes(awesome.list[[1]])

## Why is the last vector of type double and not integer?
## By default seq returns integers from:to. But the `by`
## parameter returns always doubles

## myList got no names since we did not assign any compared to our vectors
```

# Factors

```{r echo=T, results="show"}
f1 <- factor(letters)
levels(f1) <- rev(levels(f1))
f2 <- rev(factor(letters))
f3 <- factor(letters, levels = rev(letters))
```

The function `rev` reverses the order of an order-able object. What is the difference between f1, f2 and f3? Why?

```{r }

# Answer :

f1 <- factor(letters)
levels(f1) <- rev(levels(f1))
# f1 goes from z - a, but the underlying encoding goes from z = 1 to a = 26
# We create the vector with the letters a to z and the mapped integer 
# structure 1 to 26. THEN we reverse the levels = the mapping. As 1 becomes z
# and a becomes 26 the letters are mapped back to the unchanged integer
# structure and hence reversed.
f1

f2 <- rev(factor(letters))
# f2 goes from z - a, but the underlying encoding goes from a = 1 to z = 26
# We create the vector with the letters a to z and the mapped integer 
# structure 1 to 26. Then we reverse the vector, i.e. the underlying integers,
# hence the vector gets reversed, but not the levels.
f2

f3 <- factor(letters, levels = rev(letters))
# f3 goes from a - z, but the underlying encoding goes from z = 1 to a = 26. 
# We create the vector with the letters a to z BUT the mapped integer 
# structure 26 to 1. Hence the levels but not the vector are reversed.
f3

# Reversing f3 will give f1
rev(f3)
```

# Computation on matrices

Create a 10 by 5 matrix which contains the the numbers from 1 to 50 column-wise. Name the rows as 'row_n' and columns as 'col_n'. Compute the mean and sum of each row and column. Add vector seq(60,100,10) as another row to the matrix. 

Generate another matrix with the same dimensions, containing random numbers between 1 and 100. Subtract this matrix from the first one. 

Plot the covariance matrix of the columns of the resulting matrix with spearman correlation coefficients.

**Hint:** Check out functions paste0(), colMeans(), rowMeans(), colSums(), rowSums(), sample(), cor() and corrplot() (in package 'corrplot') 


```{r }
# Answer :
m <- matrix(1:50, ncol = 5) 
rownames(m) <- paste0("row_", 1:nrow(m))
colnames(m) <- paste0("col_", 1:ncol(m))
colMeans(m)
rowMeans(m)
colSums(m)
rowSums(m)

m <- rbind(m,seq(60,100,10))
n <- matrix(sample(1:100, length(m), replace=T), ncol = ncol(m))
m <- m-n
M <- cor(m, method = "spearman")
#corrplot::corrplot(M, method = "number")
```
#  Data frame manipulation

Create a 3 by 4 matrix that contains the numbers 1 to 12 and then convert it into a data frame. Assign zero to the elements at row 2 which are greater than 4. Set the rownames to "row1", "row2", "row3" and column names to "col1", "col2", "col3" and "col4". Assign 0 to all elements in columns "col3" and "col4". Add a new column named "Letters" with values c("A", "B", "C"). Inspect the structure of the data frame.

```{r}
#Answer :
x <- matrix(1:12,3,4)
x <- as.data.frame(x)
x
x[2, x[2,]>4] <- 0
rownames(x) <- paste0("row",1:3)
colnames(x) <- paste0("col",1:4)
x[,paste0("col",3:4)] <- 0
x$Letters <- c("A","B","C")
```

# Data frame operations
Compute the number of women who survived the Titanic. Start by loading the data into  a data frame using the following command:

```{r echo=T, results="show"}
tab <- read.csv("extdata/titanic.csv")
```

```{r}
head(tab)
# number of females survived the Titanic
nrow(tab[tab$sex == "female" & tab$survived == 1,])

# total number of passangers 
nrow(tab)
```

# Looping and writing your own functions

Write a function named "generateDataFrameSummary" which takes a data frame as input and outputs the  medians of the rows and columns (NA values are discarded), and number of NA values in each row and column as a list.

```{r}
#Answer :

generateDataFrameSummary <- function(inputDF){
  
  return(list( rowMedians = apply(inputDF, 1, median, na.rm=T),
               colMedians = apply(inputDF, 2, median, na.rm=T),
               rowNANum   = apply(inputDF, 1, function(x){ sum(is.na(x)) }),
               colNANum   = apply(inputDF, 2, function(x){ sum(is.na(x)) })))
  
}

# test the function
df <- as.data.frame(matrix(rnorm(1000), nrow=50))
df[sample(c(T, F), nrow(df), replace=TRUE), 
   sample(c(T, F), ncol(df), replace=TRUE)] <- NA
head(df)
generateDataFrameSummary(df)
```
