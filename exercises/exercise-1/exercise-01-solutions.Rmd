---
title: "Exercise sheet: Day 1"
author: "Vangelis Theodorakis, Fatemeh Behjati, Julien Gagneur"
date: "`r format(Sys.time(), '%d %B, %Y')`"
vignette: >
  %\VignetteIndexEntry{CeDoSIA SS2020 - Exercise Sheet 1: Introduction to R}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
output: 
  BiocStyle::pdf_document
---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(fig.width=12, fig.height=12, error=TRUE, warning=FALSE,
        message=FALSE, 
        #echo=FALSE, results="hide"
        echo=TRUE, results="show"
)
```

# Vectors 

First, create three named numeric vectors of size 10, 11 and 12 respectively in the following manner: 

- One vector with the "colon" approach: *from:to*
- One vector with the `seq()` function: *seq(from, to)*
- And one vector with the `seq()` function and the `by` argument: *seq(from, to, by)*

For easier naming you can use the vector `letters` or `LETTERS` which contain the latin alphabet in small and capital, respectively. In order to select specific letters just use e.g. `letters[1:4]` to get the first four letters. 
Check their types. What is the outcome? Where do you think the difference comes from?

Then combine all three vectors in a list. Check the attributes of the vectors and the list. What is the difference and why?


**Hint:** If list elements have no names, we can access them with the double brackets and an index, e.g. `my_list[[1]]`

```{r}
# Answer :

# A. Create vectors
vector.1 <- 1:10
names(vector.1) <- letters[vector.1]

vector.2 <- seq(1, 11)
names(vector.2) <- letters[vector.2]

vector.3 <- seq(1, 12, by = 1)
names(vector.3) <- letters[vector.3]

typeof(vector.1)
typeof(vector.2)
typeof(vector.3)

# B. Combine in a list
awesome.list <- list(vector.1, vector.2, vector.3)
attributes(vector.1)
attributes(vector.2)
attributes(vector.3)
attributes(awesome.list)
attributes(awesome.list[[1]])

## Why is the last vector of type double and not integer?
## By default seq returns integers from:to. But the `by`
## parameter returns always doubles

## myList got no names since we did not assign any compared to our vectors
```

# Factors

```{r echo=T, results="show"}
f1 <- factor(letters)
levels(f1) <- rev(levels(f1))
f2 <- rev(factor(letters))
f3 <- factor(letters, levels = rev(letters))
```

The function `rev` reverses the order of an order-able object. What is the difference between f1, f2 and f3? Why?

```{r }

# Answer :

f1 <- factor(letters)
levels(f1) <- rev(levels(f1))
# f1 goes from z - a, but the underlying encoding goes from z = 1 to a = 26
# We create the vector with the letters a to z and the mapped integer 
# structure 1 to 26. THEN we reverse the levels = the mapping. As 1 becomes z
# and a becomes 26 the letters are mapped back to the unchanged integer
# structure and hence reversed.
f1

f2 <- rev(factor(letters))
# f2 goes from z - a, but the underlying encoding goes from a = 1 to z = 26
# We create the vector with the letters a to z and the mapped integer 
# structure 1 to 26. Then we reverse the vector, i.e. the underlying integers,
# hence the vector gets reversed, but not the levels.
f2

f3 <- factor(letters, levels = rev(letters))
# f3 goes from a - z, but the underlying encoding goes from z = 1 to a = 26. 
# We create the vector with the letters a to z BUT the mapped integer 
# structure 26 to 1. Hence the levels but not the vector are reversed.
f3

# Reversing f3 will give f1
rev(f3)
```

# Data tables

The purpose of this exercise is to get familiarize with data.table and try out some of its useful features.

## Basic operations
Please follow the steps listed below:

1)  Download the GTEx data (annotation v7) from the following link:
https://storage.googleapis.com/gtex_analysis_v7/annotations/GTEx_v7_Annotations_SampleAttributesDS.txt

2) Read the file downloaded above and store it in a variable named: *data*.

3) Inspect *data* by checking properties such as: *class(data)*, *dim(data)*, *colnames(data)*, *data[1:3, 1:5]*, *unique(data$SMTS)*.

4) Count how many NA's exist in *data*.

```{r}
# Answer :
library(data.table)
data <- fread("~/GTEx_v7_Annotations_SampleAttributesDS.txt")

print("class of data is")
class(data)

print("dim of data is")
dim(data)

print("column names of data are")
colnames(data)

print("a small subset of data looks like")
data[1:3, 1:5]
      
print("tissue types in data:")
unique(data$SMTS)
```

## More exciting operations
Continue from the previous part and perform the following actions:

3) Subset the data based on the *Brain* cell type sample and store the result in a variable called: *data_Brain*.

4) Inspect the *data_Brain* similar to the point 3 above.

5) Examine the range of values in *SMEXPEFF* field of *data_Brain*. How can you make it more meaningful?

6) For *data_Brain*, compute the average of the values stored in the "SMEXPEFF" column. Also, compute the min of values stored in "SME1MPRT".

7) Compute the correlation between the two columns mentioned above.

8) Remove the rows that are NA from the *data_Brain$SMEXPEFF*. Retry the correlation on the NA-removed *data_Brain_noNA*.

**Hint:** Use the is.na() function to find the rows that are NA.
```{r}
# Answer :
#3
data_Brain <- data[data$SMTS == "Brain", ]

#4
print("class of data_Brain is")
class(data_Brain)

print("dim of data_Brain is")
dim(data_Brain)

print("column names of data_Brain are")
colnames(data_Brain)

print("a small subset of data_Brain looks like")
data_Brain[1:3, 1:5]
      
print("tissue types in data_Brain:e")
unique(data_Brain$SMTS)

#5
print("range of values in data_Brain$SMEXPEFF (Expression Profiling Efficiency):")
range(data_Brain$SMEXPEFF)

print("range of values in data_Brain$SMEXPEFF when NA's are removed:")
range(data_Brain$SMEXPEFF, na.rm= T)
#6
mean(data_Brain$SMEXPEFF)
mean(data_Brain$SMEXPEFF, na.rm= T)

min(data_Brain$SME1MPRT)
min(data_Brain$SME1MPRT, na.rm= T)
#7
cor(data_Brain$SME1MPRT, data_Brain$SMEXPEFF)
#8
data_Brain <- data_Brain[!is.na(data_Brain$SMEXPEFF), ]
cor(data_Brain$SME1MPRT, data_Brain$SMEXPEFF)
```

# Looping
- Initialize a variable called *counter* by 0.
- Using a for loop that iterates 10 times, increment *counter* by 1.
- Print the final value in *counter*.

```{r}
#Answer :

# Looping
counter <- 0
for(i in seq(10)){
  counter <- counter + 1
}
print(counter)
```
Write a function named *get_counts* that takes a GTEx data table as input and outputs the total counts of rows that the sample tissue type (*SMTS*) is *Heart* and the sample analysis freeze (*SMAFRZE*) is *RNASEQ*. How about if you try the same but for *Blood*.
If this task was too easy, can you modify your function such that instead of taking only one argument, it takes two additional ones, one for the *SMTS* and another for *SMAFRZE*. Iterate over all possible values of *SMTS* (**Hint:** *unique(data$SMTS)*) and call your function by providing the sample tissue type.

```{r}
#Answer :
get_counts <- function(gtex){
  counter <- 0
  for(i in seq(nrow(gtex)))
    if(gtex$SMTS[i] == "Heart" & gtex$SMAFRZE[i] == "RNASEQ"){
      counter <- counter + 1
    }
  return(counter)
}

fun_res <- get_counts(data)
print(fun_res)

#modified version
get_counts2 <- function(gtex, var1, var2){
  counter <- 0
  for(i in seq(nrow(gtex)))
    if(gtex$SMTS[i] == var1 & gtex$SMAFRZE[i] == var2){
      counter <- counter + 1
    }
  return(counter)
}

all_tissues <- unique(data$SMTS)
for(ts in all_tissues){
  fun_res <- get_counts2(data, ts, "RNASEQ")
  print(paste("Number of RNASEQ cases for", ts, ":", fun_res))
}

```
