<!DOCTYPE html>
<html>
<head>
  <title>Introduction to scientific data analysis and visualization in R</title>
  <meta charset="utf-8">
  <meta name="description" content="Introduction to scientific data analysis and visualization in R">
  <meta name="author" content="Basak Eraslan, Julien Gagneur">
  <meta name="generator" content="slidify" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <link rel="stylesheet" href="libraries/frameworks/io2012/css/default.css" media="all" >
  <link rel="stylesheet" href="libraries/frameworks/io2012/css/phone.css" 
    media="only screen and (max-device-width: 480px)" >
  <link rel="stylesheet" href="libraries/frameworks/io2012/css/slidify.css" >
  <link rel="stylesheet" href="libraries/highlighters/highlight.js/css/tomorrow.css" />
  <base target="_blank"> <!-- This amazingness opens all links in a new tab. -->  <link rel=stylesheet href="libraries/widgets/bootstrap/css/bootstrap.css"></link>
<link rel=stylesheet href="libraries/widgets/quiz/css/demo.css"></link>

  
  <!-- Grab CDN jQuery, fall back to local if offline -->
  <script src="http://ajax.aspnetcdn.com/ajax/jQuery/jquery-1.7.min.js"></script>
  <script>window.jQuery || document.write('<script src="libraries/widgets/quiz/js/jquery.js"><\/script>')</script> 
  <script data-main="libraries/frameworks/io2012/js/slides" 
    src="libraries/frameworks/io2012/js/require-1.0.8.min.js">
  </script>
  
  

</head>
<body style="opacity: 0">
  <slides class="layout-widescreen">
    
    <!-- LOGO SLIDE -->
        <slide class="title-slide segue nobackground">
  
  <hgroup class="auto-fadein">
    <h1>Introduction to scientific data analysis and visualization in R</h1>
    <h2>R basics (optional course)</h2>
    <p>Basak Eraslan, Julien Gagneur<br/></p>
  </hgroup>
  
  <article></article>  
  
</slide>
    

    <!-- SLIDES -->
    <slide class="" id="slide-1" style="background:;">
  
  <article data-timings="">
    <!-- Center image on slide -->

<script src="http://ajax.aspnetcdn.com/ajax/jQuery/jquery-1.7.min.js"></script>

<script type='text/javascript'>
$(function() {
    $("p:has(img)").addClass('centered');
});
</script>

<p></script></p>

<script type = 'text/javascript'>
$('p:has(img.build)').addClass('build')
</script>

<h2>R studio</h2>

<ul>
<li>console</li>
<li>plot</li>
<li>help</li>
<li>history</li>
<li>environment</li>
<li>script</li>
<li>packages</li>
</ul>

  </article>
  <!-- Presenter Notes -->
  
</slide>

<slide class="" id="slide-2" style="background:;">
  
  <hgroup>
    <h2>Data structures</h2>
  </hgroup>
  
  <article data-timings="">
    <table><thead>
<tr>
<th>Dim</th>
<th>Homogeneous</th>
<th>Heterogeneous</th>
</tr>
</thead><tbody>
<tr>
<td>1d</td>
<td>Atomic vector</td>
<td>List</td>
</tr>
<tr>
<td>2d</td>
<td>Matrix</td>
<td>Data Frame</td>
</tr>
<tr>
<td>nd</td>
<td>Array</td>
<td></td>
</tr>
</tbody></table>

<p><strong>Notes:</strong>  </p>

<ul>
<li>Scalars are just vectors of length one<br></li>
<li>Use <code>str()</code> to see the structure of an object</li>
<li>All more complex objects, like <em>S3</em>, <em>S4</em> or <em>Reference classes</em> are build from this structures</li>
<li>Additionally R uses <em>attributes</em> to store metadata about an object</li>
</ul>

  </article>
  <!-- Presenter Notes -->
  
</slide>

<slide class="" id="slide-3" style="background:;">
  
  <hgroup>
    <h2>Vector objects</h2>
  </hgroup>
  
  <article data-timings="">
    <table><thead>
<tr>
<th>typeof</th>
<th>mode</th>
<th>storage.mode</th>
</tr>
</thead><tbody>
<tr>
<td>logical</td>
<td>logical</td>
<td>logical</td>
</tr>
<tr>
<td>integer</td>
<td>numeric</td>
<td>integer</td>
</tr>
<tr>
<td>double</td>
<td>numeric</td>
<td>double</td>
</tr>
<tr>
<td>complex</td>
<td>complex</td>
<td>complex</td>
</tr>
<tr>
<td>character</td>
<td>character</td>
<td>character</td>
</tr>
</tbody></table>

<p></br></p>

<p>In practice no distinction is made between doubles and integers. They are just &quot;numerics&quot;.<br>
Numerics are by default doubles:</p>

<pre><code class="r">typeof(1)
</code></pre>

<pre><code>## [1] &quot;double&quot;
</code></pre>

<pre><code class="r">typeof(1L)
</code></pre>

<pre><code>## [1] &quot;integer&quot;
</code></pre>

  </article>
  <!-- Presenter Notes -->
  
</slide>

<slide class="" id="slide-4" style="background:;">
  
  <hgroup>
    <h2>Atomic vectors</h2>
  </hgroup>
  
  <article data-timings="">
    <p>Usually created with <code>c()</code> (from <em>concatenation</em>):</p>

<pre><code class="r">c(1, 5, 8, 10)
</code></pre>

<pre><code>## [1]  1  5  8 10
</code></pre>

<pre><code class="r">str(c(1, 5, 8, 10))
</code></pre>

<pre><code>##  num [1:4] 1 5 8 10
</code></pre>

<pre><code class="r">length(c(1, 5, 8, 10))
</code></pre>

<pre><code>## [1] 4
</code></pre>

<pre><code class="r">c(&quot;a&quot;, &quot;B&quot;, &quot;cc&quot;)
</code></pre>

<pre><code>## [1] &quot;a&quot;  &quot;B&quot;  &quot;cc&quot;
</code></pre>

<pre><code class="r">c(TRUE, FALSE, c(TRUE, TRUE))
</code></pre>

<pre><code>## [1]  TRUE FALSE  TRUE  TRUE
</code></pre>

  </article>
  <!-- Presenter Notes -->
  
</slide>

<slide class="" id="slide-5" style="background:;">
  
  <hgroup>
    <h2>Numerics: Create a sequence</h2>
  </hgroup>
  
  <article data-timings="">
    <p>Create an integer sequence <em>from:to</em> by <em>step</em></p>

<pre><code class="r">1:10 
</code></pre>

<pre><code>##  [1]  1  2  3  4  5  6  7  8  9 10
</code></pre>

<pre><code class="r">seq(from = 1, to = 10, by = .3)
</code></pre>

<pre><code>##  [1]  1.0  1.3  1.6  1.9  2.2  2.5  2.8  3.1  3.4  3.7  4.0  4.3  4.6  4.9  5.2
## [16]  5.5  5.8  6.1  6.4  6.7  7.0  7.3  7.6  7.9  8.2  8.5  8.8  9.1  9.4  9.7
## [31] 10.0
</code></pre>

<pre><code class="r">seq(from = 1, to = 10, length.out = 20)
</code></pre>

<pre><code>##  [1]  1.000000  1.473684  1.947368  2.421053  2.894737  3.368421  3.842105
##  [8]  4.315789  4.789474  5.263158  5.736842  6.210526  6.684211  7.157895
## [15]  7.631579  8.105263  8.578947  9.052632  9.526316 10.000000
</code></pre>

  </article>
  <!-- Presenter Notes -->
  
</slide>

<slide class="" id="slide-6" style="background:;">
  
  <hgroup>
    <h2>Others: Create a sequence</h2>
  </hgroup>
  
  <article data-timings="">
    <p>The <em>replicate</em> function <code>rep()</code> replicates a vector a certain number of <em>times</em> and concatenates them: </p>

<pre><code class="r">rep(c(TRUE, FALSE), times = 5)
</code></pre>

<pre><code>##  [1]  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE
</code></pre>

<p></br></p>

<p>To replicate <em>each</em> entry of the input vector at the time:</p>

<pre><code class="r">rep(c(TRUE, FALSE), each = 5)
</code></pre>

<pre><code>##  [1]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE
</code></pre>

  </article>
  <!-- Presenter Notes -->
  
</slide>

<slide class="" id="slide-7" style="background:;">
  
  <hgroup>
    <h2>Assignments</h2>
  </hgroup>
  
  <article data-timings="">
    <p>Assignments in R are preferably of this form:</p>

<blockquote>
<p>objectName &lt;- value</p>
</blockquote>

<p>It is also possible to assign with the <em>equal</em> sign.</p>

<blockquote>
<p>objectName = value</p>
</blockquote>

<p>However, the &quot;equal&quot;&quot; sign is used for argument passing to functions. Thus if nesting, the equal sign will be interpreted as a argument assignment and might throw an error:</p>

<pre><code class="r">## We want to measure the running time of the inner product of a large vector and 
## assign the outcome of the function to a variable simultaneously
system.time(a &lt;- t(1:1e6)%*%(1:1e6))
</code></pre>

<pre><code>##    user  system elapsed 
##   0.044   0.003   0.047
</code></pre>

<pre><code class="r">system.time(a = t(1:1e6)%*%(1:1e6))
</code></pre>

<pre><code>## Error in system.time(a = t(1:1e+06) %*% (1:1e+06)): unused argument (a = t(1:1e+06) %*% (1:1e+06))
</code></pre>

  </article>
  <!-- Presenter Notes -->
  
</slide>

<slide class="" id="slide-8" style="background:;">
  
  <hgroup>
    <h2>Accessing and assigning vector elements</h2>
  </hgroup>
  
  <article data-timings="">
    <p>Vector elements are accessed via the <code>[</code> operator:</p>

<pre><code class="r">## Create an A,B,C,D,E vector
x &lt;- LETTERS[1:5]
x
</code></pre>

<pre><code>## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot;
</code></pre>

<pre><code class="r">## access the third entry
x[3]
</code></pre>

<pre><code>## [1] &quot;C&quot;
</code></pre>

<pre><code class="r">## modify the third entry
x[3] &lt;- &#39;Z&#39;
x
</code></pre>

<pre><code>## [1] &quot;A&quot; &quot;B&quot; &quot;Z&quot; &quot;D&quot; &quot;E&quot;
</code></pre>

  </article>
  <!-- Presenter Notes -->
  
</slide>

<slide class="" id="slide-9" style="background:;">
  
  <hgroup>
    <h2>Working with missing values</h2>
  </hgroup>
  
  <article data-timings="">
    <p>Missing values are specified with <code>NA</code>. They are placeholders for the specific type and as such are something like an unspecified value. If not taken care of, it can break computation, e.g. What is the sum of [1, 3, 5, x] if you do not know x?</p>

<pre><code class="r">## Define a vector containing a missing value (NA)
v &lt;- c(1,3,5,NA) 
</code></pre>

<p></br></p>

<p>Now we try to compute its mean:</p>

<pre><code class="r">mean(v)
</code></pre>

<pre><code>## [1] NA
</code></pre>

<p></br></p>

<p>For many functions including <code>mean()</code>, a <code>na.rm</code> parameter allows ignoring missing values:</p>

<pre><code class="r">mean(v, na.rm = TRUE)
</code></pre>

<pre><code>## [1] 3
</code></pre>

  </article>
  <!-- Presenter Notes -->
  
</slide>

<slide class="" id="slide-10" style="background:;">
  
  <hgroup>
    <h2>Named vectors</h2>
  </hgroup>
  
  <article data-timings="">
    <p>Elements in vectors can have names. 
Using names instead of index to access entries in a vector make code more robust to re-ordering, subsetting, and changes in data input.<br>
Names can be created at initialization or set afterwards with <code>names()</code>. </p>

<pre><code class="r">x &lt;- c(a = 1, b = 2, c = 3)
x
</code></pre>

<pre><code>## a b c 
## 1 2 3
</code></pre>

<pre><code class="r">names(x) &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)
x
</code></pre>

<pre><code>## A B C 
## 1 2 3
</code></pre>

  </article>
  <!-- Presenter Notes -->
  
</slide>

<slide class="" id="slide-11" style="background:;">
  
  <hgroup>
    <h2>Names: Properties</h2>
  </hgroup>
  
  <article data-timings="">
    <p>Names don&#39;t have to be unique, but should preferably be, as subsetting by names will only return the first match</p>

<pre><code class="r">x &lt;- c(a = 1, a = 2, b = 3)
x[&quot;a&quot;]
</code></pre>

<pre><code>## a 
## 1
</code></pre>

<p></br>
Not all elements need to have names.</p>

<pre><code class="r">c(a = 1, 2, 3)
</code></pre>

<pre><code>## a     
## 1 2 3
</code></pre>

  </article>
  <!-- Presenter Notes -->
  
</slide>

<slide class="" id="slide-12" style="background:;">
  
  <hgroup>
    <h2>Exercise: vectors</h2>
  </hgroup>
  
  <article data-timings="">
    
  </article>
  <!-- Presenter Notes -->
  
</slide>

<slide class="" id="slide-13" style="background:;">
  
  <hgroup>
    <h2>Special Vector Type: Factors</h2>
  </hgroup>
  
  <article data-timings="">
    <pre><code class="r">x &lt;- factor(c(&quot;red&quot;, &quot;yellow&quot;, &quot;red&quot;,&quot;green&quot;, &quot;green&quot;))
x
</code></pre>

<pre><code>## [1] red    yellow red    green  green 
## Levels: green red yellow
</code></pre>

<ul>
<li><p>A factor is a is used to store categorical data. The distinct categories are called &#39;levels&#39;.</p></li>
<li><p>They belong to a special <code>class()</code>, <em>factor</em>, which makes them behave differently from regular integer vectors</p></li>
<li><p>Factors are built on top of integer vectors: the values are integer indexes in the dictionary of levels.</p></li>
<li><p>They occupy less space in memory than characters, since they are stored as integers</p></li>
</ul>

<table><thead>
<tr>
<th>Level</th>
<th>Integer</th>
</tr>
</thead><tbody>
<tr>
<td>green</td>
<td>1</td>
</tr>
<tr>
<td>red</td>
<td>2</td>
</tr>
<tr>
<td>yellow</td>
<td>3</td>
</tr>
</tbody></table>

  </article>
  <!-- Presenter Notes -->
  
</slide>

<slide class="" id="slide-14" style="background:;">
  
  <hgroup>
    <h2>Factors: R code</h2>
  </hgroup>
  
  <article data-timings="">
    <ul>
<li>Factors are typically constructed with <code>factor()</code>. By default the levels are the unique values, sorted by alphanumerical order. </li>
</ul>

<pre><code class="r">x &lt;- factor(c(&quot;red&quot;, &quot;yellow&quot;, &quot;red&quot;,&quot;green&quot;, &quot;green&quot;))
x
</code></pre>

<pre><code>## [1] red    yellow red    green  green 
## Levels: green red yellow
</code></pre>

<p><code>levels()</code> gives the levels in ascending order of the underlying encoding integers.</p>

<pre><code class="r">levels(x)
</code></pre>

<pre><code>## [1] &quot;green&quot;  &quot;red&quot;    &quot;yellow&quot;
</code></pre>

  </article>
  <!-- Presenter Notes -->
  
</slide>

<slide class="" id="slide-15" style="background:;">
  
  <hgroup>
    <h2>Factors: Properties</h2>
  </hgroup>
  
  <article data-timings="">
    <p>The order of the levels can be forced:</p>

<pre><code class="r">x &lt;- factor(c(&quot;red&quot;, &quot;yellow&quot;, &quot;red&quot;,&quot;green&quot;, &quot;green&quot;), levels=c(&quot;green&quot;, &quot;yellow&quot;, &quot;red&quot;))
x
</code></pre>

<pre><code>## [1] red    yellow red    green  green 
## Levels: green yellow red
</code></pre>

<pre><code class="r">levels(x)
</code></pre>

<pre><code>## [1] &quot;green&quot;  &quot;yellow&quot; &quot;red&quot;
</code></pre>

<p></br>
The order of the levels is then used for all function requiring comparisons, e.g. sorting </p>

<pre><code class="r">sort(x)
</code></pre>

<pre><code>## [1] green  green  yellow red    red   
## Levels: green yellow red
</code></pre>

  </article>
  <!-- Presenter Notes -->
  
</slide>

<slide class="" id="slide-16" style="background:;">
  
  <hgroup>
    <h2>Factors: Properties II</h2>
  </hgroup>
  
  <article data-timings="">
    <p>Only level values can be used:</p>

<pre><code class="r">x &lt;- factor(c(&quot;red&quot;, &quot;yellow&quot;, &quot;red&quot;,&quot;green&quot;, &quot;green&quot;))
x[2] &lt;- &quot;blue&quot;
</code></pre>

<pre><code>## Warning in `[&lt;-.factor`(`*tmp*`, 2, value = &quot;blue&quot;): invalid factor level, NA
## generated
</code></pre>

<pre><code class="r">x
</code></pre>

<pre><code>## [1] red   &lt;NA&gt;  red   green green
## Levels: green red yellow
</code></pre>

<p></br>
Do not try to combine factors, especially if levels are not the same!</p>

<p><code>Be aware:</code> R does not prevent you from combining factors:</p>

<pre><code class="r">c(x, factor(&quot;blue&quot;))
</code></pre>

<pre><code>## [1]  2 NA  2  1  1  1
</code></pre>

  </article>
  <!-- Presenter Notes -->
  
</slide>

<slide class="" id="slide-17" style="background:;">
  
  <hgroup>
    <h2>Exercise: factors</h2>
  </hgroup>
  
  <article data-timings="">
    
  </article>
  <!-- Presenter Notes -->
  
</slide>

<slide class="" id="slide-18" style="background:;">
  
  <hgroup>
    <h2>Math</h2>
  </hgroup>
  
  <article data-timings="">
    <ul>
<li>Basic mathematical operations: <code>+</code>, <code>*</code>, <code>-</code>, <code>/</code></li>
<li>Additional mathematical operations: 

<ul>
<li><code>%*%</code> Matrix multiplication, for vectors: inner product (dot product)</li>
<li><code>%%</code> Modulo</li>
<li><code>%/%</code> Integer division</li>
<li><code>%o%</code> Outer product</li>
<li><code>^</code> Exponentiating</li>
</ul></li>
<li>Boolean operations:

<ul>
<li><code>&amp;</code> elementwise AND</li>
<li><code>&amp;&amp;</code> AND left to right until the result is determined</li>
<li><code>|</code> elementwise OR</li>
<li><code>||</code> OR left to right until the result is determined</li>
<li><code>!</code> NOT</li>
<li><code>xor(x,y)</code> elementwise XOR (exclusive OR)</li>
</ul></li>
</ul>

  </article>
  <!-- Presenter Notes -->
  
</slide>

<slide class="" id="slide-19" style="background:;">
  
  <hgroup>
    <h2>Binary comparison</h2>
  </hgroup>
  
  <article data-timings="">
    <ul>
<li><p>Elementwise Binary comparison return a vector of same length as the input</p>

<ul>
<li><code>==</code> elementwise equality</li>
<li><code>!=</code> elementwise inequality</li>
<li><code>&lt;</code>, <code>&lt;=</code> elementwise smaller (or equal)</li>
<li><code>&gt;</code>, <code>&gt;=</code> elementwise greater (or equal)</li>
</ul></li>
<li><p>Binary comparison with a single boolean statement as output</p>

<ul>
<li><code>identical(x, y)</code> exact equality</li>
<li><code>all(x)</code> are all TRUE?</li>
</ul></li>
</ul>

<pre><code class="r">1:5 == 1:5
</code></pre>

<pre><code>## [1] TRUE TRUE TRUE TRUE TRUE
</code></pre>

<pre><code class="r">identical(1:5, 1:5)
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

  </article>
  <!-- Presenter Notes -->
  
</slide>

<slide class="" id="slide-20" style="background:;">
  
  <hgroup>
    <h2>Matrices</h2>
  </hgroup>
  
  <article data-timings="">
    <p>2-dimensional structures that can be created by <code>matrix()</code></p>

<pre><code class="r">x &lt;- 1:12
x
</code></pre>

<pre><code>##  [1]  1  2  3  4  5  6  7  8  9 10 11 12
</code></pre>

<pre><code class="r">mat &lt;- matrix(x, 2, 6)
mat
</code></pre>

<pre><code>##      [,1] [,2] [,3] [,4] [,5] [,6]
## [1,]    1    3    5    7    9   11
## [2,]    2    4    6    8   10   12
</code></pre>

<pre><code class="r">dim(mat)
</code></pre>

<pre><code>## [1] 2 6
</code></pre>

  </article>
  <!-- Presenter Notes -->
  
</slide>

<slide class="" id="slide-21" style="background:;">
  
  <hgroup>
    <h2>Matrices: Attributes</h2>
  </hgroup>
  
  <article data-timings="">
    <p>Vector attributes generalizes differently for matrices as dimensions change:</p>

<p></br>
<code>length()</code> becomes <code>nrow()</code> and <code>ncol()</code></p>

<pre><code class="r">nrow(mat)
</code></pre>

<pre><code>## [1] 2
</code></pre>

<pre><code class="r">ncol(mat)
</code></pre>

<pre><code>## [1] 6
</code></pre>

<p></br>
<code>names()</code> becomes <code>rownames()</code> and <code>colnames()</code></p>

<pre><code class="r">colnames(mat) &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;)
rownames(mat) &lt;- c(&quot;a&quot;, &quot;b&quot;)
mat
</code></pre>

<pre><code>##   A B C D  E  F
## a 1 3 5 7  9 11
## b 2 4 6 8 10 12
</code></pre>

  </article>
  <!-- Presenter Notes -->
  
</slide>

<slide class="" id="slide-22" style="background:;">
  
  <hgroup>
    <h2>Matrices: Attributes II</h2>
  </hgroup>
  
  <article data-timings="">
    <p><code>c()</code> becomes <code>cbind()</code> (column-bind) and <code>rbind()</code> (row-bind):</p>

<pre><code class="r">mat &lt;- matrix(c(1, 2, 4, 5), 2, 2)
cmat &lt;- matrix(7:8, 2, 1)
rmat &lt;- matrix(c(3, 6, 9), 1, 3)
mat
</code></pre>

<pre><code>##      [,1] [,2]
## [1,]    1    4
## [2,]    2    5
</code></pre>

<pre><code class="r">mat &lt;- cbind(mat, cmat)
mat &lt;- rbind(mat, rmat)
mat
</code></pre>

<pre><code>##      [,1] [,2] [,3]
## [1,]    1    4    7
## [2,]    2    5    8
## [3,]    3    6    9
</code></pre>

  </article>
  <!-- Presenter Notes -->
  
</slide>

<slide class="" id="slide-23" style="background:;">
  
  <hgroup>
    <h2>Column-wise computation</h2>
  </hgroup>
  
  <article data-timings="">
    <p>Operations between a vector and a matrix is done column-wise:</p>

<pre><code class="r">mat &lt;- matrix(1, 3, 2)
mat
</code></pre>

<pre><code>##      [,1] [,2]
## [1,]    1    1
## [2,]    1    1
## [3,]    1    1
</code></pre>

<pre><code class="r">vec &lt;- 1:3
vec
</code></pre>

<pre><code>## [1] 1 2 3
</code></pre>

<pre><code class="r">mat*vec
</code></pre>

<pre><code>##      [,1] [,2]
## [1,]    1    1
## [2,]    2    2
## [3,]    3    3
</code></pre>

  </article>
  <!-- Presenter Notes -->
  
</slide>

<slide class="" id="slide-24" style="background:;">
  
  <hgroup>
    <h2>Column-wise computation cont.</h2>
  </hgroup>
  
  <article data-timings="">
    <ul>
<li>This behaviour comes from the fact that all objects in R are basically vectors, which are just &quot;folded&quot; column-wise</li>
<li>Elements of the shorter vector are constantly reused.</li>
</ul>

<pre><code class="r">as.vector(mat) * vec
</code></pre>

<pre><code>## [1] 1 2 3 1 2 3
</code></pre>

<pre><code class="r">mat * 1:2
</code></pre>

<pre><code>##      [,1] [,2]
## [1,]    1    2
## [2,]    2    1
## [3,]    1    2
</code></pre>

  </article>
  <!-- Presenter Notes -->
  
</slide>

<slide class="" id="slide-25" style="background:;">
  
  <hgroup>
    <h2>Column-wise computation cont.</h2>
  </hgroup>
  
  <article data-timings="">
    <ul>
<li>Elements of the shorter vector are constantly reused. If the shorter vector is a multiple of the longer vector, the computation succeeds, otherwise it will run till end and throw a warning</li>
</ul>

<pre><code class="r">mat
</code></pre>

<pre><code>##      [,1] [,2]
## [1,]    1    1
## [2,]    1    1
## [3,]    1    1
</code></pre>

<pre><code class="r">mat * 1:4
</code></pre>

<pre><code>## Warning in mat * 1:4: longer object length is not a multiple of shorter object
## length
</code></pre>

<pre><code>##      [,1] [,2]
## [1,]    1    4
## [2,]    2    1
## [3,]    3    2
</code></pre>

  </article>
  <!-- Presenter Notes -->
  
</slide>

<slide class="" id="slide-26" style="background:;">
  
  <hgroup>
    <h2>Exercise: Computation on matrices</h2>
  </hgroup>
  
  <article data-timings="">
    
  </article>
  <!-- Presenter Notes -->
  
</slide>

<slide class="" id="slide-27" style="background:;">
  
  <hgroup>
    <h2>Heterogeneous vectors: Lists</h2>
  </hgroup>
  
  <article data-timings="">
    <p>Lists are heterogeneous vectors, that is the elements can be of <em>any type</em>, including lists (recursivity). Construct lists by using <code>list()</code>:</p>

<pre><code class="r">x &lt;- list(c(1,2,3), &quot;some text&quot;, list(c(TRUE, FALSE)))
x
</code></pre>

<pre><code>## [[1]]
## [1] 1 2 3
## 
## [[2]]
## [1] &quot;some text&quot;
## 
## [[3]]
## [[3]][[1]]
## [1]  TRUE FALSE
</code></pre>

<p></br>
<code>typeof</code> list is <em>list</em>:</p>

<pre><code class="r">typeof(x)
</code></pre>

<pre><code>## [1] &quot;list&quot;
</code></pre>

  </article>
  <!-- Presenter Notes -->
  
</slide>

<slide class="" id="slide-28" style="background:;">
  
  <hgroup>
    <h2>Accessing and assigning list elements (1)</h2>
  </hgroup>
  
  <article data-timings="">
    <p>List elements are accessed via the <code>[[</code> operator:</p>

<pre><code class="r">## Create an A,B,C list
x &lt;- as.list(LETTERS[1:3])
x
</code></pre>

<pre><code>## [[1]]
## [1] &quot;A&quot;
## 
## [[2]]
## [1] &quot;B&quot;
## 
## [[3]]
## [1] &quot;C&quot;
</code></pre>

<pre><code class="r">## access the third element with `[[`
x[[3]]
</code></pre>

<pre><code>## [1] &quot;C&quot;
</code></pre>

  </article>
  <!-- Presenter Notes -->
  
</slide>

<slide class="" id="slide-29" style="background:;">
  
  <hgroup>
    <h2>Accessing and assigning list elements (2)</h2>
  </hgroup>
  
  <article data-timings="">
    <pre><code class="r">## modify the third element
x[[3]] &lt;- &#39;Z&#39;
x
</code></pre>

<pre><code>## [[1]]
## [1] &quot;A&quot;
## 
## [[2]]
## [1] &quot;B&quot;
## 
## [[3]]
## [1] &quot;Z&quot;
</code></pre>

<pre><code class="r">## accessed with only a single `[` we get a list of the given index
x[3]
</code></pre>

<pre><code>## [[1]]
## [1] &quot;Z&quot;
</code></pre>

  </article>
  <!-- Presenter Notes -->
  
</slide>

<slide class="" id="slide-30" style="background:;">
  
  <hgroup>
    <h2>Data Frames</h2>
  </hgroup>
  
  <article data-timings="">
    <ul>
<li><em>Data frames</em> are the most common way to store data</li>
<li>It&#39;s a list of equal-length vectors</li>
<li>Because of this 2-dimensional structure it shares properties of a <em>list</em> and a <em>matrix</em></li>
<li>So a data frame has <code>rownames()</code> and <code>colnames()</code> = <code>names()</code></li>
<li>It has also <code>nrow()</code> and <code>ncol()</code> = <code>length()</code></li>
<li><code>length()</code> actually returns the number of <em>list elements</em>, which is the column dimension</li>
<li>Data frames are created with <code>data.frame()</code> and named vectors (also lists) or matrices as input</li>
</ul>

<pre><code class="r">df &lt;- data.frame(number = 1:4, letter = letters[1:4])
df
</code></pre>

<pre><code>##   number letter
## 1      1      a
## 2      2      b
## 3      3      c
## 4      4      d
</code></pre>

  </article>
  <!-- Presenter Notes -->
  
</slide>

<slide class="" id="slide-31" style="background:;">
  
  <hgroup>
    <h2>Data Frames: Names</h2>
  </hgroup>
  
  <article data-timings="">
    <ul>
<li>Matrices and lists can be without names, but data frames not</li>
<li>If an unnamed vector or matrix is provided, names are set by default.</li>
<li>The functions <code>colnames</code> and <code>rownames</code> can be used to view and set the names.</li>
</ul>

<pre><code class="r">rownames(df)
</code></pre>

<pre><code>## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot;
</code></pre>

<pre><code class="r">rownames(df) &lt;- paste0(&quot;row_&quot;, nrow(df):1)
rownames(df)
</code></pre>

<pre><code>## [1] &quot;row_4&quot; &quot;row_3&quot; &quot;row_2&quot; &quot;row_1&quot;
</code></pre>

  </article>
  <!-- Presenter Notes -->
  
</slide>

<slide class="" id="slide-32" style="background:;">
  
  <hgroup>
    <h2>Combining</h2>
  </hgroup>
  
  <article data-timings="">
    <ul>
<li>Combining works with <code>cbind()</code> and <code>rbind()</code> like in matrices and with <code>c()</code> like in lists.</li>
<li>If combining column-wise, the number of rows must match</li>
<li>If combining row-wise, <strong>the number and column names have to match</strong></li>
</ul>

<pre><code class="r">df &lt;- data.frame(number = 1:2, letter = letters[1:2])
cbind(df, data.frame(cont = 5:6))
</code></pre>

<pre><code>##   number letter cont
## 1      1      a    5
## 2      2      b    6
</code></pre>

<pre><code class="r">rbind(df, data.frame(n = 3, l = letters[3]))
</code></pre>

<pre><code>## Error in match.names(clabs, names(xi)): names do not match previous names
</code></pre>

<pre><code class="r">rbind(df, data.frame(number = 3, letter = letters[3]))
</code></pre>

<pre><code>##   number letter
## 1      1      a
## 2      2      b
## 3      3      c
</code></pre>

  </article>
  <!-- Presenter Notes -->
  
</slide>

<slide class="" id="slide-33" style="background:;">
  
  <hgroup>
    <h2>Subsetting</h2>
  </hgroup>
  
  <article data-timings="">
    <ul>
<li><p>There are three subsetting methods</p>

<ul>
<li><code>[</code> For vectors</li>
<li><code>[[</code> For list-based structures</li>
<li><code>$</code> Similar to the prior</li>
</ul></li>
<li><p>Six ways of subsetting</p>

<ul>
<li>By positive integers</li>
<li>By negative integers</li>
<li>By logical vectors</li>
<li>Empty subsetting</li>
<li>By Zero</li>
<li>Character vector</li>
</ul></li>
</ul>

  </article>
  <!-- Presenter Notes -->
  
</slide>

<slide class="" id="slide-34" style="background:;">
  
  <hgroup>
    <h2>Atomic vectors</h2>
  </hgroup>
  
  <article data-timings="">
    <pre><code class="r">x &lt;- LETTERS[1:5]
x
</code></pre>

<pre><code>## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot;
</code></pre>

<pre><code class="r">x[c(1,3)]
</code></pre>

<pre><code>## [1] &quot;A&quot; &quot;C&quot;
</code></pre>

<pre><code class="r">x[-c(1,3)]
</code></pre>

<pre><code>## [1] &quot;B&quot; &quot;D&quot; &quot;E&quot;
</code></pre>

<pre><code class="r">x[c(TRUE, TRUE, TRUE, FALSE, FALSE)]
</code></pre>

<pre><code>## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot;
</code></pre>

<pre><code class="r">x[x &lt;= &quot;C&quot;]
</code></pre>

<pre><code>## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot;
</code></pre>

  </article>
  <!-- Presenter Notes -->
  
</slide>

<slide class="" id="slide-35" style="background:;">
  
  <hgroup>
    <h2>Atomic vectors cont.</h2>
  </hgroup>
  
  <article data-timings="">
    <p><code>NAs</code> in the vector will always produce an <code>NA</code> in the output:</p>

<pre><code class="r">x[c(1,2,NA)]
</code></pre>

<pre><code>## [1] &quot;A&quot; &quot;B&quot; NA
</code></pre>

<p>Subsetting by character vectors, if names are present</p>

<pre><code class="r">names(x) &lt;- letters[1:5]
x[c(&quot;a&quot;, &quot;b&quot;)]
</code></pre>

<pre><code>##   a   b 
## &quot;A&quot; &quot;B&quot;
</code></pre>

  </article>
  <!-- Presenter Notes -->
  
</slide>

<slide class="" id="slide-36" style="background:;">
  
  <hgroup>
    <h2>Subsetting: Lists</h2>
  </hgroup>
  
  <article data-timings="">
    <p>Lists behave just like atomic vectors. The output is a list</p>

<pre><code class="r">myList &lt;- list(&quot;char&quot;=c(&quot;a&quot;, &quot;b&quot;), &quot;int&quot;=1:5, &quot;logic&quot;=TRUE)
myList[1]
</code></pre>

<pre><code>## $char
## [1] &quot;a&quot; &quot;b&quot;
</code></pre>

<pre><code class="r">myList[[1]]
</code></pre>

<pre><code>## [1] &quot;a&quot; &quot;b&quot;
</code></pre>

<pre><code class="r">myList[&quot;int&quot;]
</code></pre>

<pre><code>## $int
## [1] 1 2 3 4 5
</code></pre>

<pre><code class="r">myList[c(FALSE, TRUE, FALSE)];myList[-c(1,3)]
</code></pre>

<pre><code>## $int
## [1] 1 2 3 4 5
</code></pre>

<pre><code>## $int
## [1] 1 2 3 4 5
</code></pre>

  </article>
  <!-- Presenter Notes -->
  
</slide>

<slide class="" id="slide-37" style="background:;">
  
  <hgroup>
    <h2>Subsetting: Matrices</h2>
  </hgroup>
  
  <article data-timings="">
    <pre><code class="r">mat &lt;- matrix(1:9, 3, 3)
colnames(mat) &lt;- LETTERS[1:3]
mat
</code></pre>

<pre><code>##      A B C
## [1,] 1 4 7
## [2,] 2 5 8
## [3,] 3 6 9
</code></pre>

<p>Possible to mix different subsetting styles</p>

<pre><code class="r">mat[-1, c(1,2)]
</code></pre>

<pre><code>##      A B
## [1,] 2 5
## [2,] 3 6
</code></pre>

<pre><code class="r">mat[c(FALSE, TRUE, TRUE), c(&quot;A&quot;, &quot;B&quot;)]
</code></pre>

<pre><code>##      A B
## [1,] 2 5
## [2,] 3 6
</code></pre>

  </article>
  <!-- Presenter Notes -->
  
</slide>

<slide class="" id="slide-38" style="background:;">
  
  <hgroup>
    <h2>Subsetting: Data Frames</h2>
  </hgroup>
  
  <article data-timings="">
    <p>Data frames share properties of lists and matrices. Subsetting by a single vector will behave as in lists. Note the number of elements in a list
is the number of columns in the data frame. Subsetting by two vectors will behave as in matrices.</p>

<pre><code class="r">df &lt;- data.frame(matrix(1:9, 3, 3))
names(df) &lt;- letters[1:3]
df[1:2]
</code></pre>

<pre><code>##   a b
## 1 1 4
## 2 2 5
## 3 3 6
</code></pre>

<pre><code class="r">df[-1, c(&quot;a&quot;, &quot;b&quot;)]
</code></pre>

<pre><code>##   a b
## 2 2 5
## 3 3 6
</code></pre>

  </article>
  <!-- Presenter Notes -->
  
</slide>

<slide class="" id="slide-39" style="background:;">
  
  <hgroup>
    <h2>Subsetting by accessors:</h2>
  </hgroup>
  
  <article data-timings="">
    <p>The <code>[[</code> and <code>$</code> operators behave more like accessors to objects. They return only one object and as such can take generally only one input, so they are useful for lists and data frames. The <code>$</code> is a shortcut for <code>x[[name, exact = FALSE]]</code></p>

<pre><code class="r">names(df) &lt;- c(&quot;Ak&quot;, &quot;B&quot;, &quot;C&quot;)
df
</code></pre>

<pre><code>##   Ak B C
## 1  1 4 7
## 2  2 5 8
## 3  3 6 9
</code></pre>

<pre><code class="r">df[[2]]
</code></pre>

<pre><code>## [1] 4 5 6
</code></pre>

<pre><code class="r">df[[&quot;B&quot;]]
</code></pre>

<pre><code>## [1] 4 5 6
</code></pre>

<pre><code class="r">df$A ## Note there is no &#39;A&#39; column
</code></pre>

<pre><code>## [1] 1 2 3
</code></pre>

  </article>
  <!-- Presenter Notes -->
  
</slide>

<slide class="" id="slide-40" style="background:;">
  
  <hgroup>
    <h2>Subsetting and Assignment</h2>
  </hgroup>
  
  <article data-timings="">
    <p>All subsetting operators can be combined with assignments to modify a subset of values</p>

<pre><code class="r">x &lt;- c(a = 1, b = 2, c = 3)
x[2] &lt;- 10
x
</code></pre>

<pre><code>##  a  b  c 
##  1 10  3
</code></pre>

<pre><code class="r">df &lt;- data.frame(a = 1:2, b = 3:4)
df
</code></pre>

<pre><code>##   a b
## 1 1 3
## 2 2 4
</code></pre>

<pre><code class="r">df$b &lt;- c(&quot;first&quot;, &quot;second&quot;)
df
</code></pre>

<pre><code>##   a      b
## 1 1  first
## 2 2 second
</code></pre>

  </article>
  <!-- Presenter Notes -->
  
</slide>

<slide class="" id="slide-41" style="background:;">
  
  <hgroup>
    <h2>Exercise: Data frames and Data frames:Titanic</h2>
  </hgroup>
  
  <article data-timings="">
    
  </article>
  <!-- Presenter Notes -->
  
</slide>

<slide class="" id="slide-42" style="background:;">
  
  <hgroup>
    <h2>Functions</h2>
  </hgroup>
  
  <article data-timings="">
    <p>Syntax to write own function:</p>

<pre><code>myFunction &lt;- function(args1, args2 = default, ...) {
  body
  return(result)
}
</code></pre>

<ul>
<li>If the <code>return</code> statement is missing, the result of the last line will be returned</li>
<li>The parameters can be assigned default values</li>
<li>If the default value is a vector, the first value will be used by default</li>
<li>The <em>three dots</em> (<code>...</code>) in the function arguments are called <strong>ellipsis</strong> ans are used as a placeholder for any arguments passed to a function call inside. This is useful when you don&#39;t want to push all parameters from embodied function to your functions or allow for generic functions without prespecifying argument names.</li>
</ul>

<pre><code>myFunction &lt;- function(args1, args2 = c(&quot;option1&quot;, &quot;option2&quot;), ...) {
  result &lt;- doSomething(args1, ...)
  return(result)
}
myFunction(args1, args2, param1)
</code></pre>

  </article>
  <!-- Presenter Notes -->
  
</slide>

<slide class="" id="slide-43" style="background:;">
  
  <hgroup>
    <h2>Conditional Statements</h2>
  </hgroup>
  
  <article data-timings="">
    <p>Long version:</p>

<pre><code class="r">if(1 &lt; 2) {
  print(&quot;TRUE&quot;)
} else {
  print(&quot;FALSE&quot;)
}
</code></pre>

<pre><code>## [1] &quot;TRUE&quot;
</code></pre>

<p></br></p>

<p>Short version if the To-Do step fits into one line:</p>

<pre><code class="r">{
if(1 &gt; 2) print(&quot;TRUE&quot;)
else print(&quot;FALSE&quot;)
}
</code></pre>

<pre><code>## [1] &quot;FALSE&quot;
</code></pre>

<p>The curly brackets around the if-else statement are only needed in a script to tell R to which <em>if</em> the <em>else</em> belongs to.</p>

  </article>
  <!-- Presenter Notes -->
  
</slide>

<slide class="" id="slide-44" style="background:;">
  
  <hgroup>
    <h2>Looping: For loops</h2>
  </hgroup>
  
  <article data-timings="">
    <p>Syntax:</p>

<pre><code>for(index in sequence) {
  do something
}
</code></pre>

<p></br></p>

<p>Again, if the To-Do step is a one-liner, curly brackets can be droped</p>

<pre><code class="r">a &lt;- NULL
for(i in 1:10) a &lt;- c(a, sum(1:i))
a
</code></pre>

<pre><code>##  [1]  1  3  6 10 15 21 28 36 45 55
</code></pre>

<p>A sequence can be any vector, including lists</p>

<pre><code class="r">myList &lt;- list(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
a &lt;- integer(10)
for(i in myList) a[i] &lt;- sum(1:i)
a
</code></pre>

<pre><code>##  [1]  1  3  6 10 15 21 28 36 45 55
</code></pre>

  </article>
  <!-- Presenter Notes -->
  
</slide>

<slide class="" id="slide-45" style="background:;">
  
  <hgroup>
    <h2>The Apply family</h2>
  </hgroup>
  
  <article data-timings="">
    <ul>
<li>For loops condition each following step on the previous step. That means that after each step the environment is updated. </li>
<li>This leads to long running times (for the already slow looping mechanism of R)</li>
<li>In case the single steps are independent of each other, a particular function can be applied to the elements of the steps</li>
</ul>

<pre><code class="r">myList &lt;- list(1:10, 11:20, 5:14)
sapply(myList, sum)
</code></pre>

<pre><code>## [1]  55 155  95
</code></pre>

<p></br></p>

<ul>
<li>Also lambda functions can be applied</li>
</ul>

<pre><code class="r">sapply(myList, function(y) {
  sum(y)/length(y)
})
</code></pre>

<pre><code>## [1]  5.5 15.5  9.5
</code></pre>

  </article>
  <!-- Presenter Notes -->
  
</slide>

<slide class="" id="slide-46" style="background:;">
  
  <hgroup>
    <h2>R Markdown</h2>
  </hgroup>
  
  <article data-timings="">
    <ul>
<li><p>This is an R Markdown presentation. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <a href="http://rmarkdown.rstudio.com">http://rmarkdown.rstudio.com</a>. </p></li>
<li><p>Simply go to File --&gt; New File ---&gt; R Markdown</p></li>
<li><p>Select PDF and you get a template</p></li>
<li><p>You most likely won&#39;t need more commands than in on the first page of <a href="https://www.rstudio.com/wp-content/uploads/2015/03/rmarkdown-reference.pdf">this cheat sheet</a></p></li>
<li><p>When you click the <strong>Knit</strong> button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document.  </p></li>
</ul>

  </article>
  <!-- Presenter Notes -->
  
</slide>

<slide class="" id="slide-47" style="background:;">
  
  <hgroup>
    <h2>Useful references</h2>
  </hgroup>
  
  <article data-timings="">
    <ul>
<li><p>These slides are mostly based on Hadley Wickham&#39;s book <a href="http://adv-r.had.co.nz/">Advanced R</a></p></li>
<li><p><a href="http://hadley.nz/"><strong>Everything else</strong> from Hadley Wickham</a></p></li>
<li><p>In-depth documentations:</p>

<ul>
<li><a href="https://cran.r-project.org/doc/manuals/r-release/R-intro.pdf">Introduction to R</a></li>
<li><a href="https://cran.r-project.org/doc/manuals/r-release/R-lang.pdf">R language definition</a></li>
<li><a href="https://cran.r-project.org/doc/manuals/r-release/R-ints.pdf">R Internals</a></li>
</ul></li>
<li><p>Last but not least:</p>

<ul>
<li><a href="http://stackoverflow.com/questions/tagged/r">Stackoverflow</a></li>
</ul></li>
</ul>

  </article>
  <!-- Presenter Notes -->
  
</slide>

    <slide class="backdrop"></slide>
  </slides>
  <div class="pagination pagination-small" id='io2012-ptoc' style="display:none;">
    <ul>
      
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=1 title='NA'>
         1
      </a>
    </li>
    
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=2 title='Data structures'>
         2
      </a>
    </li>
    
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=3 title='Vector objects'>
         3
      </a>
    </li>
    
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=4 title='Atomic vectors'>
         4
      </a>
    </li>
    
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=5 title='Numerics: Create a sequence'>
         5
      </a>
    </li>
    
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=6 title='Others: Create a sequence'>
         6
      </a>
    </li>
    
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=7 title='Assignments'>
         7
      </a>
    </li>
    
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=8 title='Accessing and assigning vector elements'>
         8
      </a>
    </li>
    
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=9 title='Working with missing values'>
         9
      </a>
    </li>
    
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=10 title='Named vectors'>
         10
      </a>
    </li>
    
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=11 title='Names: Properties'>
         11
      </a>
    </li>
    
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=12 title='Exercise: vectors'>
         12
      </a>
    </li>
    
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=13 title='Special Vector Type: Factors'>
         13
      </a>
    </li>
    
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=14 title='Factors: R code'>
         14
      </a>
    </li>
    
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=15 title='Factors: Properties'>
         15
      </a>
    </li>
    
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=16 title='Factors: Properties II'>
         16
      </a>
    </li>
    
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=17 title='Exercise: factors'>
         17
      </a>
    </li>
    
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=18 title='Math'>
         18
      </a>
    </li>
    
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=19 title='Binary comparison'>
         19
      </a>
    </li>
    
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=20 title='Matrices'>
         20
      </a>
    </li>
    
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=21 title='Matrices: Attributes'>
         21
      </a>
    </li>
    
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=22 title='Matrices: Attributes II'>
         22
      </a>
    </li>
    
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=23 title='Column-wise computation'>
         23
      </a>
    </li>
    
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=24 title='Column-wise computation cont.'>
         24
      </a>
    </li>
    
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=25 title='Column-wise computation cont.'>
         25
      </a>
    </li>
    
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=26 title='Exercise: Computation on matrices'>
         26
      </a>
    </li>
    
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=27 title='Heterogeneous vectors: Lists'>
         27
      </a>
    </li>
    
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=28 title='Accessing and assigning list elements (1)'>
         28
      </a>
    </li>
    
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=29 title='Accessing and assigning list elements (2)'>
         29
      </a>
    </li>
    
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=30 title='Data Frames'>
         30
      </a>
    </li>
    
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=31 title='Data Frames: Names'>
         31
      </a>
    </li>
    
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=32 title='Combining'>
         32
      </a>
    </li>
    
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=33 title='Subsetting'>
         33
      </a>
    </li>
    
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=34 title='Atomic vectors'>
         34
      </a>
    </li>
    
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=35 title='Atomic vectors cont.'>
         35
      </a>
    </li>
    
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=36 title='Subsetting: Lists'>
         36
      </a>
    </li>
    
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=37 title='Subsetting: Matrices'>
         37
      </a>
    </li>
    
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=38 title='Subsetting: Data Frames'>
         38
      </a>
    </li>
    
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=39 title='Subsetting by accessors:'>
         39
      </a>
    </li>
    
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=40 title='Subsetting and Assignment'>
         40
      </a>
    </li>
    
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=41 title='Exercise: Data frames and Data frames:Titanic'>
         41
      </a>
    </li>
    
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=42 title='Functions'>
         42
      </a>
    </li>
    
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=43 title='Conditional Statements'>
         43
      </a>
    </li>
    
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=44 title='Looping: For loops'>
         44
      </a>
    </li>
    
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=45 title='The Apply family'>
         45
      </a>
    </li>
    
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=46 title='R Markdown'>
         46
      </a>
    </li>
    
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=47 title='Useful references'>
         47
      </a>
    </li>
    
    </ul>
  </div>  <!--[if IE]>
    <script 
      src="http://ajax.googleapis.com/ajax/libs/chrome-frame/1/CFInstall.min.js">  
    </script>
    <script>CFInstall.check({mode: 'overlay'});</script>
  <![endif]-->
</body>
  <!-- Load Javascripts for Widgets -->
  <script src="libraries/widgets/bootstrap/js/bootstrap.min.js"></script>
<script src="libraries/widgets/bootstrap/js/bootbox.min.js"></script>
<script src="libraries/widgets/quiz/js/jquery.quiz.js"></script>
<script src="libraries/widgets/quiz/js/mustache.min.js"></script>
<script src="libraries/widgets/quiz/js/quiz-app.js"></script>

  <!-- MathJax: Fall back to local if CDN offline but local image fonts are not supported (saves >100MB) -->
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        processEscapes: true
      }
    });
  </script>
  <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/2.0-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <!-- <script src="https://c328740.ssl.cf1.rackcdn.com/mathjax/2.0-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script> -->
  
<script>window.MathJax || document.write('<script type="text/x-mathjax-config">MathJax.Hub.Config({"HTML-CSS":{imageFont:null}});<\/script><script src="libraries/widgets/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"><\/script>')
</script>

  <script>  
  $(function (){ 
    $("#example").popover(); 
    $("[rel='tooltip']").tooltip(); 
  });  
  </script>  
  
  <!-- LOAD HIGHLIGHTER JS FILES -->
  <script src="libraries/highlighters/highlight.js/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  <!-- DONE LOADING HIGHLIGHTER JS FILES -->
   
  </html>